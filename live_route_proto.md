# Live Route Prototype for `rpc`

## Context

Current `rpc` flow is unary request/response only:

- Rust service endpoints are generated by `impl_rpc!` and exposed as `POST /rpc/<group>/<fn>`.
- TS bindings are generated as ArkType schemas plus `ServiceDefinitions` with `route({ endpoint, input, output })` calls.
- There is no runtime or bindgen concept for subscriptions or streaming updates.

This proposal adds live data sync while keeping SSR/server usage as a normal one-shot request.

## Product requirements (from request)

- Client is always TypeScript (server or browser).
- Browser should get live sync over WebSocket.
- Server-side rendering should fetch data once (normal request path).

## Proposed model

Treat a live endpoint as a single logical route with two transport modes:

- **Snapshot mode (SSR/server):** regular HTTP request, one response.
- **Live mode (browser):** WebSocket subscription, stream of updates.

For an endpoint `v1/feed`:

- `POST /rpc/v1/feed` -> snapshot response
- `GET /rpc/v1/feed` with WS upgrade -> stream updates

This keeps endpoint naming consistent and lets SSR reuse existing HTTP infra.

## TS API shape (generated)

Generate a second route constructor for live routes (in `@izvir/rpc`), for example `liveRoute`.

```ts
import { route, liveRoute } from "@izvir/rpc";

export const ServiceDefinitions = {
  v1: {
    getUser: route({ endpoint: "v1/get_user", input: GetUserProps, output: GetUserResponse }),
    feed: liveRoute({ endpoint: "v1/feed", input: FeedProps, output: FeedState }),
  },
} as const;
```

Expected ergonomic behavior:

- `route(...)` remains unchanged.
- `liveRoute(...)` provides:
  - `call(client, input)` for one-shot snapshot (SSR-friendly)
  - `subscribe(client, input, handlers)` for browser live updates

Example:

```ts
// SSR or server
const snap = await ServiceDefinitions.v1.feed.call(client, { channelId });

// Browser
const sub = ServiceDefinitions.v1.feed.subscribe(client, { channelId }, {
  next: (state) => render(state),
  error: (err) => console.error(err),
  complete: () => console.log("closed"),
});

// later
sub.unsubscribe();
```

## Rust API shape

Keep existing `impl_rpc!` untouched and add a parallel macro for live routes.

### Option A (recommended): explicit live macro

Add `impl_live_rpc!` and a new attribute macro `#[live_handler(v1)]` that mirrors current patterns.

Conceptual expansion:

- Registers snapshot handler for `POST`.
- Registers WS handler for `GET` upgrade.
- Registers bindgen entry with call kind `Live`.

Potential handler contract:

```rust
pub async fn feed_snapshot(
    ctx: &mut Ctx,
    props: FeedProps,
) -> Result<FeedState, errx::Error>

pub async fn feed_stream(
    ctx: &mut Ctx,
    props: FeedProps,
) -> Result<impl futures_core::Stream<Item = Result<FeedState, errx::Error>> + Send + 'static, errx::Error>
```

Then:

```rust
rpc::impl_live_rpc!(
    v1,
    FeedProps,
    FeedState,
    MyContext,
    feed_snapshot,
    feed_stream
);
```

### Option B: one macro with mode flags

Extend `impl_rpc!` to accept a mode (`unary` vs `live`).

This is less desirable because it complicates an existing stable macro surface and weakens clarity.

## Transport protocol for WebSocket

Use JSON messages initially (simple, debuggable).

Client -> server first frame:

```json
{ "type": "subscribe", "input": { ...FeedProps } }
```

Server -> client frames:

```json
{ "type": "snapshot", "data": { ...FeedState } }
{ "type": "update", "data": { ...FeedState } }
{ "type": "error", "error": { "message": "...", "trace_id": "..." } }
{ "type": "complete" }
```

Design notes:

- Snapshot can be sent as first WS event for immediate render.
- Keep events stateless at first (full-state updates), add patch/diff later only if needed.
- Preserve trace ID behavior (`x-trace-id`) where possible (query/header negotiation on upgrade).

## Bindgen changes in `rpc`

Current bindgen stores route definitions as preformatted strings. For live routes, move to a structured internal model.

### Current structure

- `RpcCalls.calls: BTreeMap<String, Vec<String>>`

### Proposed structure

```rust
enum CallKind {
    Unary,
    Live,
}

struct RpcCallDef {
    key: String,
    endpoint: String,
    input: String,
    output: String,
    kind: CallKind,
}

RpcCalls.calls: BTreeMap<String, Vec<RpcCallDef>>
```

Then generator renders:

- `route(...)` for `Unary`
- `liveRoute(...)` for `Live`

This avoids fragile string surgery and makes future extensions easier.

## Server routing changes

### Existing

- `Endpoint` stores `path` + `MethodRouter` builder
- `router()` mounts all inventory endpoints

### Proposed

Keep same `Endpoint` mechanism, but live registration creates a `MethodRouter` with:

- `post(snapshot_handler)`
- `get(ws_upgrade_handler)`

No change required for callers of `rpc::router()`.

## Backward compatibility

- Existing unary RPCs and generated TS bindings remain valid.
- Live support is additive.
- `@izvir/rpc` needs a minor release adding `liveRoute` but does not break `route`.

## Incremental implementation plan

1. Add internal `CallKind` + structured bindgen definitions.
2. Add `liveRoute(...)` emission in TS generator.
3. Add runtime live endpoint registration in `rpc` with WS upgrade handling.
4. Add `impl_live_rpc!` macro and optional `#[live_handler]` proc-macro sugar.
5. Add `rpc_test` coverage:
   - golden TS includes one `liveRoute`
   - snapshot HTTP path returns once
   - WS subscription emits expected message sequence
6. Add docs/examples for SSR (`call`) and browser (`subscribe`).

## Open decisions

- Whether WS messages should always include a discriminant (`type`) even for data frames (recommended: yes).
- Whether live routes should support optional heartbeat/ping policy now or later (recommended: later, keep MVP simple).
- Whether live updates should be full-state only in v1 (recommended: yes).

## Recommendation

Implement live sync as an additive `impl_live_rpc!` + generated `liveRoute(...)` pair.

This gives:

- one-shot SSR compatibility with normal HTTP,
- browser live updates over WebSocket,
- minimal disruption to current unary RPC behavior and binding generation.
